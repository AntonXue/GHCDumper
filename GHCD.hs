-- | GHC Dump Tool

-- You may need to do: $ ghc -package ghc GHCD.h
-- Some options are commented out for GHC 7.0.3 vs GHC 8.0.2

import BasicTypes
import Coercion
import CorePrep
import CoreSyn
import CoreToStg
import CostCentre
import DataCon
import FastString
import ForeignCall
import GHC
import GHC.Paths
import GhcMonad
import HscTypes
import Literal
import Module
import Name
import Outputable
import Pair
import PrimOp
import SrcLoc
import StgSyn
import TyCon
import TyCoRep  -- GHC 8.0.2
-- import TypeRep  -- GHC 7.10.3
import Type
import UniqSet
import Unique
import Var

import System.IO
import System.Environment

import Data.List
import Data.Maybe

-- | Make IO String from Outputable
--   Simple print dump.
mkIOStr :: (Outputable a) => a -> IO String
mkIOStr obj = runGhc (Just libdir) $ do
    -- Appropriate dynamic flags not relevant here.
    dflags <- getSessionDynFlags
    let ppr_str = showPpr dflags obj
    return ppr_str

-- | Compilation Closure
--   This allows us to capture the ModGuts of each module relevant to the
--   dependency graph (as generated by the target.hs) that we are compiling.
--   Furthermore, capturing the DynFlags and HscEnv essentially allows us to
--   instantiate GHC compilation environments.
mkCompileClosure :: FilePath -> FilePath ->
                    IO ([(ModSummary, ModGuts)], DynFlags, HscEnv) 
mkCompileClosure proj src = runGhc (Just libdir) $ do
    dflags <- getSessionDynFlags
    let dflags' = dflags { importPaths = [proj] }
    setSessionDynFlags dflags'
    env    <- getSession
    target <- guessTarget src Nothing
    setTargets [target]
    load LoadAllTargets

    mod_graph <- getModuleGraph
    pmods     <- mapM parseModule mod_graph
    tmods     <- mapM typecheckModule pmods
    dmods     <- mapM desugarModule tmods
    let mod_gutss = map coreModule dmods
    return (zip mod_graph mod_gutss, dflags', env)

-- | Make Multiple Core Programs
--   Concat them, because `type CoreProgram = [CoreBind]`.
mkMultiCoreProgram :: FilePath -> FilePath -> IO CoreProgram
mkMultiCoreProgram proj src = do
    (sums_gutss, dflags, env) <- mkCompileClosure proj src
    return $ concatMap (mg_binds . snd) sums_gutss

-- | Make Multiple [StgBinding]
mkMultiStgBindings :: FilePath -> FilePath -> IO [StgBinding]
mkMultiStgBindings proj src = do
    (sums_gutss, dflags, env) <- mkCompileClosure proj src
    let sums    = map fst sums_gutss
    let md_lcs  = map (\s -> (ms_mod s, ms_location s)) sums
    let m_bndss = map (mg_binds . snd) sums_gutss
    let tcss    = map (mg_tcs . snd) sums_gutss
    
    let z1 = zip3 md_lcs m_bndss tcss
    -- preps <- sequence $ map (\((m, l), b, t) -> corePrepPgm env l b t) z1
    preps <- sequence $ map (\((m, l), b, t) -> corePrepPgm env m l b t) z1

    let z2 = zip (map fst md_lcs) preps
    stg_bndss <- sequence $ map (\(m, p) -> coreToStg dflags m p) z2
    return $ concat stg_bndss

err_msg = "GHCD [--core | --stg] <proj-dir> <src-file>"

main = do
    args <- getArgs
    case args of
        []         -> error err_msg
        (a:[])     -> error err_msg
        (a:b:[])   -> error err_msg
        (opt:proj:src:[]) -> case opt of
            "--core" -> do
                core_prog <- mkMultiCoreProgram proj src
                putStrLn =<< mkIOStr core_prog

            "--stg" -> do
                stg_binds <- mkMultiStgBindings proj src
                putStrLn =<< mkIOStr stg_binds

            otherwise -> error err_msg
        otherwise -> error err_msg

